<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderhopper.spatialtools API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderhopper.spatialtools</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderhopper.spatialtools.speed_of_sound"><code class="name flex">
<span>def <span class="ident">speed_of_sound</span></span>(<span>temperature=20.0, c=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def speed_of_sound(temperature=20., c=None):
    &#34;&#34;&#34; Converts between temperature and speed of sound in dry air.
        For the given temperature in degrees Celsius, calculates the speed of
        sound as linear approximation of the actual temperature dependency. If
        a speed measurement is specified instead, estimates the corresponding
        temperature. Valid for temperatures between around -80 and 50 °C.

    Parameters
    ----------
    temperature : float or int, optional
        Air temperature in °C. The default is 20.
    c : float or int, optional
        Speed of sound in m/s. Overrides temperature if specified.
        The default is None.

    Returns
    -------
    c : float
        Speed of sound in dry air at the specified temperature in m/s.
    temperature : float
        Temperature corresponding to the specified speed of sound in °C.
    &#34;&#34;&#34;
    if c is not None:
        return (c - 331.5) / 0.606  
    return 0.606 * temperature + 331.5</code></pre>
</details>
<div class="desc"><p>Converts between temperature and speed of sound in dry air.
For the given temperature in degrees Celsius, calculates the speed of
sound as linear approximation of the actual temperature dependency. If
a speed measurement is specified instead, estimates the corresponding
temperature. Valid for temperatures between around -80 and 50 °C.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>temperature</code></strong> :&ensp;<code>float</code> or <code>int</code>, optional</dt>
<dd>Air temperature in °C. The default is 20.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code> or <code>int</code>, optional</dt>
<dd>Speed of sound in m/s. Overrides temperature if specified.
The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code></dt>
<dd>Speed of sound in dry air at the specified temperature in m/s.</dd>
<dt><strong><code>temperature</code></strong> :&ensp;<code>float</code></dt>
<dd>Temperature corresponding to the specified speed of sound in °C.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.complete_coordinates"><code class="name flex">
<span>def <span class="ident">complete_coordinates</span></span>(<span>points, index, template=0.0, n=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_coordinates(points, index, template=0., n=None):
    &#34;&#34;&#34; Validates and standardizes point coordinates to common dimensionality.
        Equalizes inferior coordinate dimensionality (less than n coordinates)
        by inserting the available coordinates at the position given by index
        in an appropriately sized 1D array with values given by template.

    Parameters
    ----------
    points : array-like (m,) of array-likes or floats or ints or None
        Collection of points to be standardized.
    index : int or array-like of ints, optional
        Dimensions at which to insert coordinates of inferior dimensionality.
    template : float or array-like of floats or None, optional
        Value(s) of the 1D array in which to insert coordinates of inferior
        dimensionality. Iterables must be of length n. If None, attempts to
        generate a template from those points that already have n coordinates,
        as long as they are consistent across all dimensions not in index.
        The default is 0.0.
    n : int, optional
        Requested coordinate dimensionality for all points. If None, uses the
        maximum dimensionality found across points. The default is None.

    Returns
    -------
    points : list (m,) of 1D arrays (n,) of floats
        Collection of points in standard format and of common dimensionality.
        Undefined points (Nones) are returned as such.

    Raises
    ------
    ValueError
        Breaks if points have more than n coordinates or are incompatible with
        index. Breaks for negative or out-of-bounds indices. If template is
        None, breaks during template generation if either no points with n
        coordinates are available or if coordinates are inconsistent.
    &#34;&#34;&#34;    
    # Input interpretation:
    if not isinstance(points, list):
        points = list(points)
    if not is_valid_numpy_index(index) or not np.iterable(index):
        index = np.atleast_1d(index).astype(int)

    # Ensure array format and count dimensions:
    n_dims = np.zeros(len(points), dtype=int)
    for i, point in enumerate(points):
        if point is not None:
            # Handle points with defined coordinates:
            points[i] = np.atleast_1d(point).astype(float)
            n_dims[i] = points[i].size
        else:
            # Undefined coordinates:
            points[i] = np.array([])

    # Manage target:
    max_dims = n_dims.max()
    if n is None:
        n = max_dims
    elif n &lt; max_dims:
        raise ValueError(f&#39;Point dimensionality {max_dims} exceeds &#39;\
                         f&#39;requested coordinate dimensionality {n}.&#39;)

    # Equality early exit:
    if n_dims.min() == n:
        return points
        
    # Validate indices for insertion:
    invalid = (index &lt; 0) | (index &gt;= n)
    if any(invalid):
        txt = string_series(index[invalid], prefix=[&#39;index&#39;, &#39;indices&#39;])
        raise ValueError(f&#39;Invalid {txt} for requested &#39;\
                         f&#39;coordinate dimensionality {n}.&#39;)
    elif any(~np.isin(n_dims, [n, index.size, 0])):
        msg = &#39;Point dimensionalities must match either the requested &#39;\
             f&#39;coordinate dimensionality {n} or the index size {index.size}.&#39;
        raise ValueError(msg)

    # Prepare insertion:
    if template is None:
        # Get points of sufficient dimensionality:
        completed = np.nonzero(n_dims == n)[0]
        error = &#39;Failed to generate template for coordinate insertion: &#39;
        if not completed.size:
            raise ValueError(f&#39;{error}No points with requested coordinate &#39;\
                             f&#39;dimensionality {n} available.&#39;)

        # Derive fixed coordinate values for unspecified dimensions:
        template = np.mean([points[ind] for ind in completed], axis=0)
        no_index = ~np.isin(np.arange(n), index)
        invalid = template[no_index] != points[completed[0]][no_index]
        if any(invalid):
            invalid = np.arange(n)[no_index][np.nonzero(invalid)[0]]
            txt = string_series(invalid, prefix=[&#39;dimension&#39;, &#39;dimensions&#39;])
            raise ValueError(f&#39;{error}Point coordinates are &#39;\
                             f&#39;inconsistent along {txt}.&#39;)
        
    # Equalize point dimensionalities:
    for i, point in enumerate(points):
        if point.size == 0:
            points[i] = None
        elif point.size &lt; n:
            points[i] = np.zeros(n) + template
            points[i][index] = point
    return points</code></pre>
</details>
<div class="desc"><p>Validates and standardizes point coordinates to common dimensionality.
Equalizes inferior coordinate dimensionality (less than n coordinates)
by inserting the available coordinates at the position given by index
in an appropriately sized 1D array with values given by template.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>array-like (m,)</code> of <code>array-likes</code> or <code>floats</code> or <code>ints</code> or <code>None</code></dt>
<dd>Collection of points to be standardized.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code> or <code>array-like</code> of <code>ints</code>, optional</dt>
<dd>Dimensions at which to insert coordinates of inferior dimensionality.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code>float</code> or <code>array-like</code> of <code>floats</code> or <code>None</code>, optional</dt>
<dd>Value(s) of the 1D array in which to insert coordinates of inferior
dimensionality. Iterables must be of length n. If None, attempts to
generate a template from those points that already have n coordinates,
as long as they are consistent across all dimensions not in index.
The default is 0.0.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Requested coordinate dimensionality for all points. If None, uses the
maximum dimensionality found across points. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>list (m,)</code> of <code>1D arrays (n,)</code> of <code>floats</code></dt>
<dd>Collection of points in standard format and of common dimensionality.
Undefined points (Nones) are returned as such.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Breaks if points have more than n coordinates or are incompatible with
index. Breaks for negative or out-of-bounds indices. If template is
None, breaks during template generation if either no points with n
coordinates are available or if coordinates are inconsistent.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.collinear_coordinates"><code class="name flex">
<span>def <span class="ident">collinear_coordinates</span></span>(<span>points, axis)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collinear_coordinates(points, axis):
    &#34;&#34;&#34; Validates and standardizes point coordinates on a line in 2D space.
        Checks if all points are on a vertical or horizontal line and redefines
        each point as a single coordinate along axis with a common line offset
        along the dimension perpendicular to axis.

    Parameters
    ----------
    points : array-like (m,) of array-likes (1 or 2,) or floats or ints or None
        Collection of points to be standardized.
    axis : int
        Dimension of 2D space along which the points are aligned. Options are
        either 0 (horizontal along x-axis) or 1 (vertical along y-axis).

    Returns
    -------
    points : array-like (m,) of floats or None
        Collection of points defined as single coordinates along axis.
        Undefined points (Nones) are returned as such.
    offset : float
        Common line offset along the dimension perpendicular to axis.
    &#34;&#34;&#34;
    # Check general coordinate format:
    is_iterable = np.nonzero([np.iterable(point) for point in points])[0]

    # Axis line early exit:
    if not is_iterable.size:
        return [None if p is None else float(p) for p in points], 0.0

    # Check if any points are defined in 2D space:
    is_dual = [i in is_iterable and len(p) &gt; 1 for i, p in enumerate(points)]
    is_dual = np.nonzero(is_dual)[0]

    # Determine line offset:
    if is_dual.size == 0:
        offset = 0.0
    elif is_dual.size == 1:
        # Define offset by only available 2D point:
        offset = float(points[is_dual[0]][1 - axis])
    else:
        # Validate common offset for all available 2D points:
        points = complete_coordinates(points, axis, template=None, n=2)
        offset = points[0][1 - axis]
        return [None if p is None else p[axis] for p in points], offset
    
    # Ensure mutable iterable:
    if not isinstance(points, list):
        points = list(points)

    # Re-define points:
    for i in is_iterable:
        points[i] = points[i][axis] if i in is_dual else points[i][0]
    return [None if p is None else float(p) for p in points], offset</code></pre>
</details>
<div class="desc"><p>Validates and standardizes point coordinates on a line in 2D space.
Checks if all points are on a vertical or horizontal line and redefines
each point as a single coordinate along axis with a common line offset
along the dimension perpendicular to axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>array-like (m,)</code> of <code>array-likes (1</code> or <code>2,)</code> or <code>floats</code> or <code>ints</code> or <code>None</code></dt>
<dd>Collection of points to be standardized.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of 2D space along which the points are aligned. Options are
either 0 (horizontal along x-axis) or 1 (vertical along y-axis).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>array-like (m,)</code> of <code>floats</code> or <code>None</code></dt>
<dd>Collection of points defined as single coordinates along axis.
Undefined points (Nones) are returned as such.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Common line offset along the dimension perpendicular to axis.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.duplicate_coordinates"><code class="name flex">
<span>def <span class="ident">duplicate_coordinates</span></span>(<span>points)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def duplicate_coordinates(points):
    &#34;&#34;&#34; Checks if any of the specified point coordinates are identical.
        Duplicate points lead to zero division in most estimation functions.
        All point coordinates must be standardized to common dimensionality. 

    Parameters
    ----------
    points : array-like (m,) of array-likes (1 or 2,) or floats or ints
        Collection of standardized points to be validated. If 1D, checks for
        duplicate values. If 2D, checks for duplicate rows. Lists and tuples
        are converted to arrays, as long as they yield homogenous shapes.

    Returns
    -------
    True or False
        Indicates whether points contains any duplicate coordinates.
    &#34;&#34;&#34;    
    if np.unique(points, axis=0).shape[0] &lt; len(points):
        print(&#39;WARNING: Insufficient spatial information. &#39;\
              &#39;Two or more channels are at the same position.&#39;)
        return True
    return False</code></pre>
</details>
<div class="desc"><p>Checks if any of the specified point coordinates are identical.
Duplicate points lead to zero division in most estimation functions.
All point coordinates must be standardized to common dimensionality. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>array-like (m,)</code> of <code>array-likes (1</code> or <code>2,)</code> or <code>floats</code> or <code>ints</code></dt>
<dd>Collection of standardized points to be validated. If 1D, checks for
duplicate values. If 2D, checks for duplicate rows. Lists and tuples
are converted to arrays, as long as they yield homogenous shapes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code> or <code>False</code></dt>
<dd>Indicates whether points contains any duplicate coordinates.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.estimate_c"><code class="name flex">
<span>def <span class="ident">estimate_c</span></span>(<span>p2, p3, p4, t2, t3, t4, p1=0.0, axis=1, validate=True, y_first=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_c(p2, p3, p4, t2, t3, t4, p1=0., axis=1, validate=True, y_first=False):
    &#34;&#34;&#34; Four-point method to estimate the speed of sound in a microphone array.
        Operates along a linear (horizontal or vertical) microphone array with
        a single reference channel at position p1 and three additional channels
        at positions p2, p3, and p4, which have a measured signal transmission
        delay t2, t3, and t4 relative to reference. Initial runtime from sender
        to reference (or the sender position itself) is not required. The order
        of channel positions (p1, p2, p3, p4) along the array is irrelevant.
        Both the channel positions and the time delays can be negative-valued.
        Accepts channel positions as both 2D and single coordinates, as long as
        all points are on a line in 2D space with an orientation given by axis.

    Parameters
    ----------
    p2 : float or int or array-like (2,) of floats or ints
        Position of channel 2 (first additional channel) along the array in m.
    p3 : float or int or array-like (2,) of floats or ints
        Position of channel 3 (second additional channel) along the array in m.
    p4 : float or int or array-like (2,) of floats or ints
        Position of channel 4 (third additional channel) along the array in m.
    t2 : float or int
        Signal transmission delay between reference and channel 2 in s.
    t3 : float or int
        Signal transmission delay between reference and channel 3 in s.
    t4 : float or int
        Signal transmission delay between reference and channel 4 in s.
    p1 : float or int or array-like (2,) of floats or ints, optional
        Position of channel 1 (reference channel) along the array in m.
        The default is 0.0.
    axis : int, optional
        Dimension of 2D space along which the array is oriented. Options are
        either 0 (horizontal along x-axis) or 1 (vertical along y-axis).
        Ignored if validate is False. The default is 1.
    validate : bool, optional
        If True, calls collinear_coordinates() on p1, p2, p3, and p4 to ensure
        that the orientation of the array is either horizontal or vertical, and
        redefines each point as a single coordinate along axis. If False, all
        channel positions must already be scalar. The default is True.

    Returns
    -------
    sos : float or np.nan
        Estimated speed of sound at the time of recording in m/s. Returns NaN
        if there is no valid solution, supressing any np.sqrt() RuntimeWarning.
        Exits with warning if any of the four channel positions are not unique.
    &#34;&#34;&#34;
    if validate:
        # Standardize and validate point coordinates:
        (p1, p2, p3, p4), _ = collinear_coordinates([p1, p2, p3, p4], axis)

    # Zero division early exit:
    if duplicate_coordinates([p1, p2, p3, p4]):
        shape = broadcastable(vars=[t2, t3, t4], crash=True)
        return np.full(shape, np.nan)

    # Calculate equation terms:
    s1, s2, s3, s4 = p1**2, p2**2, p3**2, p4**2
    if y_first:
        # Scheduled order of estimation: c -&gt; y -&gt; t1 -&gt; x:
        numerator = t2 * t2 * (s3*p1 - s1*p3 + s1*p4 - s4*p1 + s4*p3 - s3*p4)
        numerator += t2 * t3 * (s1*p2 - s2*p1 + s4*p1 - s1*p4 + s2*p4 - s4*p2)
        numerator += t2 * t4 * (s2*p1 - s1*p2 + s1*p3 - s3*p1 + s3*p2 - s2*p3)

        denominator = t2**3 * t3 * (p4 - p1)
        denominator += t2**3 * t4 * (p1 - p3)
        denominator += t2**2 * t3**2 * (p1 - p4)
        denominator += t2**2 * t4**2 * (p3 - p1)
        denominator += t2**2 * t3 * t4 * (p1 - p2)
        denominator += t2**2 * t3 * t4 * (p2 - p1)
        denominator += t2 * t3**2 * t4 * (p2 - p1)
        denominator += t2 * t3 * t4**2 * (p1 - p2)
    else:
        # Scheduled order of estimation: c -&gt; t1 -&gt; y -&gt; x:
        numerator = t2 * (s1 * (p1*p3 - p1*p4 - p2*p3 + p2*p4) + s3 * (p1*p2 + p1*p4 - p2*p4 - s1) - s4 * (p1*p2 + p1*p3 - p2*p3 - s1))
        numerator += t3 * (s1 * (-p1*p2 + p1*p4 - p2*p4 + s2) + s2 * (-p1*p2 - p1*p4 + p2*p4 + s1) + s4 * (2*p1*p2 - s1 - s2))
        numerator -= t4 * (s1 * (-p1*p2 + p1*p3 - p2*p3 + s2) + s2 * (-p1*p2 - p1*p3 + p2*p3 + s1) + s3 * (2*p1*p2 - s1 - s2))

        denominator = t2**2 * (t4*(p1*p2 + p1*p3 - p2*p3 - s1) - t3*(p1*p2 + p1*p4 - p2*p4 - s1))
        denominator += t3**2 * (t4*(-2*p1*p2 + s1 + s2) - t2*(-p1*p2 - p1*p4 + p2*p4 + s1))
        denominator += t4**2 * (t2*(-p1*p2 - p1*p3 + p2*p3 + s1) - t3*(-2*p1*p2 + s1 + s2))
    # Insert terms and solve equation if possible:
    return np.sqrt(safe_fraction(numerator, denominator, sign=[0, 1]))</code></pre>
</details>
<div class="desc"><p>Four-point method to estimate the speed of sound in a microphone array.
Operates along a linear (horizontal or vertical) microphone array with
a single reference channel at position p1 and three additional channels
at positions p2, p3, and p4, which have a measured signal transmission
delay t2, t3, and t4 relative to reference. Initial runtime from sender
to reference (or the sender position itself) is not required. The order
of channel positions (p1, p2, p3, p4) along the array is irrelevant.
Both the channel positions and the time delays can be negative-valued.
Accepts channel positions as both 2D and single coordinates, as long as
all points are on a line in 2D space with an orientation given by axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p2</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Position of channel 2 (first additional channel) along the array in m.</dd>
<dt><strong><code>p3</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Position of channel 3 (second additional channel) along the array in m.</dd>
<dt><strong><code>p4</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Position of channel 4 (third additional channel) along the array in m.</dd>
<dt><strong><code>t2</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Signal transmission delay between reference and channel 2 in s.</dd>
<dt><strong><code>t3</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Signal transmission delay between reference and channel 3 in s.</dd>
<dt><strong><code>t4</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Signal transmission delay between reference and channel 4 in s.</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>Position of channel 1 (reference channel) along the array in m.
The default is 0.0.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of 2D space along which the array is oriented. Options are
either 0 (horizontal along x-axis) or 1 (vertical along y-axis).
Ignored if validate is False. The default is 1.</dd>
<dt><strong><code>validate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, calls collinear_coordinates() on p1, p2, p3, and p4 to ensure
that the orientation of the array is either horizontal or vertical, and
redefines each point as a single coordinate along axis. If False, all
channel positions must already be scalar. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sos</code></strong> :&ensp;<code>float</code> or <code>np.nan</code></dt>
<dd>Estimated speed of sound at the time of recording in m/s. Returns NaN
if there is no valid solution, supressing any np.sqrt() RuntimeWarning.
Exits with warning if any of the four channel positions are not unique.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.estimate_t1_first"><code class="name flex">
<span>def <span class="ident">estimate_t1_first</span></span>(<span>p2, p3, t2, t3, c, p1=0.0, axis=1, validate=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_t1_first(p2, p3, t2, t3, c, p1=0., axis=1, validate=True):
    if validate:
        # Standardize and validate point coordinates:
        (p1, p2, p3), _ = collinear_coordinates([p1, p2, p3], axis)

    # Zero division early exit:
    if duplicate_coordinates([p1, p2, p3]):
        shape = broadcastable(vars=[t2, t3, c], crash=True)
        return np.full(shape, np.nan)

    # Calculate equation terms:
    numerator = (t2 * c)**2 * (p3 - p1)
    numerator += (t3 * c)**2 * (p1 - p2)
    numerator += p1**2 * (p3 - p2) + p2**2 * (p1 - p3) + p3**2 * (p2 - p1)
    denominator = 2 * c**2 * (t2 * (p1 - p3) - t3 * (p1 - p2))
    # Insert terms and solve equation if possible:
    return safe_fraction(numerator, denominator)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderhopper.spatialtools.estimate_t1"><code class="name flex">
<span>def <span class="ident">estimate_t1</span></span>(<span>p2, t2, c, y, p1=0.0, axis=1, validate=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_t1(p2, t2, c, y, p1=0., axis=1, validate=True):
    &#34;&#34;&#34; Two-point method to get the initial delay between sender and reference.
        Operates along a linear (horizontal or vertical) microphone array with
        a single reference channel at position p1 and one additional channel at
        position p2 which has a measured signal transmission delay t2 relative
        to reference. Both the channel positions and the time delay can be
        negative-valued. Accepts channel positions as both 2D and single
        coordinates, as long as all points are on a line in 2D space with
        an orientation given by axis.

    Parameters
    ----------
    p2 : float or int or array-like (2,) of floats or ints
        Position of channel 2 (non-reference) along the array in m.
    t2 : float or int
        Signal transmission delay between reference and channel 2 in s.
    y : float or int
        Sender position along the dimension specified by axis in m.
    c : float or int
        Speed of sound at the time of recording in m/s.
    p1 : float or int or array-like (2,) of floats or ints, optional
        Position of channel 1 (reference channel) along the array in m.
        The default is 0.0.
    axis : int, optional
        Dimension of 2D space along which the array is oriented. Options are
        either 0 (horizontal along x-axis) or 1 (vertical along y-axis).
        Ignored if validate is False. The default is 1.
    validate : bool, optional
        If True, calls collinear_coordinates() on p1 and p2 to ensure that the
        orientation of the array is either horizontal or vertical, redefining
        each point as a single coordinate along axis. If False, all channel
        positions must already be scalar. The default is True.

    Returns
    -------
    t1 : float or np.nan
        Initial runtime between sender and reference in s. Returns NaN if there
        is no valid solution, supressing any ZeroDivisionError.
    &#34;&#34;&#34;    
    if validate:
        # Standardize and validate point coordinates:
        (p1, p2), _ = collinear_coordinates([p1, p2], axis)

    # Zero division early exit:
    if duplicate_coordinates([p1, p2]):
        shape = broadcastable(vars=[t2, c, y], crash=True)
        return np.full(shape, np.nan)

    # Calculate equation terms:
    numerator = 2 * y * (p1 - p2) - p1**2 + p2**2 - (t2 * c)**2
    denominator = 2 * t2 * c**2
    # Insert terms and solve equation if possible:
    return safe_fraction(numerator, denominator)</code></pre>
</details>
<div class="desc"><p>Two-point method to get the initial delay between sender and reference.
Operates along a linear (horizontal or vertical) microphone array with
a single reference channel at position p1 and one additional channel at
position p2 which has a measured signal transmission delay t2 relative
to reference. Both the channel positions and the time delay can be
negative-valued. Accepts channel positions as both 2D and single
coordinates, as long as all points are on a line in 2D space with
an orientation given by axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p2</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Position of channel 2 (non-reference) along the array in m.</dd>
<dt><strong><code>t2</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Signal transmission delay between reference and channel 2 in s.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Sender position along the dimension specified by axis in m.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Speed of sound at the time of recording in m/s.</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>Position of channel 1 (reference channel) along the array in m.
The default is 0.0.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of 2D space along which the array is oriented. Options are
either 0 (horizontal along x-axis) or 1 (vertical along y-axis).
Ignored if validate is False. The default is 1.</dd>
<dt><strong><code>validate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, calls collinear_coordinates() on p1 and p2 to ensure that the
orientation of the array is either horizontal or vertical, redefining
each point as a single coordinate along axis. If False, all channel
positions must already be scalar. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t1</code></strong> :&ensp;<code>float</code> or <code>np.nan</code></dt>
<dd>Initial runtime between sender and reference in s. Returns NaN if there
is no valid solution, supressing any ZeroDivisionError.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.estimate_y_first"><code class="name flex">
<span>def <span class="ident">estimate_y_first</span></span>(<span>p2, p3, t2, t3, c, p1=0.0, axis=1, validate=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_y_first(p2, p3, t2, t3, c, p1=0., axis=1, validate=True):
    if validate:  
        # Standardize and validate point coordinates:
        (p1, p2, p3), _ = collinear_coordinates([p1, p2, p3], axis)

    # Zero division early exit:
    if duplicate_coordinates([p1, p2, p3]):
        shape = broadcastable(vars=[t2, t3, c], crash=True)
        return np.full(shape, np.nan)

    # Calculate equation terms:
    numerator = t2 * (p1**2 - p3**2 + (t3 * c)**2)
    numerator += t3 * (p2**2 - p1**2 - (t2 * c)**2)
    denominator = 2 * t2 * (p1 - p3) - 2 * t3 * (p1 - p2)
    # Insert terms and solve equation if possible:
    return safe_fraction(numerator, denominator)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderhopper.spatialtools.estimate_y"><code class="name flex">
<span>def <span class="ident">estimate_y</span></span>(<span>p2, t2, c, t1, p1=0.0, axis=1, validate=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_y(p2, t2, c, t1, p1=0., axis=1, validate=True):
    if validate:
        # Standardize and validate point coordinates:
        (p1, p2), _ = collinear_coordinates([p1, p2], axis)

    # Zero division early exit:
    if duplicate_coordinates([p1, p2]):
        shape = broadcastable(vars=[t2, c, t1], crash=True)
        return np.full(shape, np.nan)

    # Calculate equation terms:
    numerator = (t2 * c)**2 + 2 * t1 * t2 * c**2 + p1**2 - p2**2
    denominator = 2 * (p1 - p2)
    # Insert terms and solve equation if possible:
    return safe_fraction(numerator, denominator)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderhopper.spatialtools.estimate_x"><code class="name flex">
<span>def <span class="ident">estimate_x</span></span>(<span>p2, t2, c, t1, y, p1=0.0, axis=1, validate=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_x(p2, t2, c, t1, y, p1=0., axis=1, validate=True):

    offset = 0.0
    if validate:  
        # Standardize and validate point coordinates:
        (p1, p2), offset = collinear_coordinates([p1, p2], axis)

    # Zero division early exit:
    if duplicate_coordinates([p1, p2]):
        shape = broadcastable(vars=[t2, c, t1, y], crash=True)
        return np.full(shape, np.nan)

    # Calculate terms of second coordinate:
    adjacent, hypotenuse = abs(y - p2), (t1 + t2) * c

    # Solve equation if Pythagoras holds:
    squared_sides = hypotenuse**2 - adjacent**2
    return np.nan if squared_sides &lt; 0 else np.sqrt(squared_sides) + offset</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderhopper.spatialtools.filter_estimates"><code class="name flex">
<span>def <span class="ident">filter_estimates</span></span>(<span>estimates, groups, full_return=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_estimates(estimates, groups, full_return=False):
    &#34;&#34;&#34; Checks which inputs are most likely responsible for unsolved equations.
        Following combination-wise estimation of some variable, gets all input
        combinations that produced NaN estimates and ranks the associated group
        members by frequency of occurence in unsolved equations relative to the
        total occurence in groups. Iterates over most frequent members until
        all unsolved equations can be linked to at least one responsible input.

    Parameters
    ----------
    estimates : list or tuple or 1D array (m,) of floats or ints or np.nans
        Estimated variable for each group, as returned by combi_estimation().
        All invalid outputs must be marked as NaN. No other values supported.
    groups : 2D array (m, n) of floats or ints
        Unique combinations of n inputs, as returned by combi_estimation().
    full_return : bool, optional
        If True, returns the subset of valid estimates and corresponding groups
        in addition to the remaining group members. The default is False.

    Returns
    -------
    estimates : 1D array (q,) of floats or ints, optional
        Subset of valid estimates, equal to estimates[~np.isnan(estimates)].
        Returned in first place if full_return is True, else omitted.
    groups : 2D array (q, n) of floats or ints, optional
        Subset of valid groups, equal to groups[~np.isnan(groups)].
        Returned in second place if full_return is True, else omitted.
    members : 1D array (p,) of floats or ints
        Remaining unique group members, likely not linked to any NaN estimates.
    &#34;&#34;&#34;    
    # Identify unsolved equations:
    nan_inds = np.isnan(estimates)
    nan_groups = groups[nan_inds]

    # Count occurences of each unique member across all groups:
    all_members, all_counts = np.unique(groups, return_counts=True)

    # All valid early exit:
    if not nan_groups.size:
        return (estimates, groups, all_members) if full_return else all_members

    # Count occurences of unique members across NaN-associated groups:
    nan_members, nan_counts = np.unique(nan_groups, return_counts=True)

    # Sort members by frequency of occurence in descending order:
    ratios = nan_counts / all_counts[np.isin(all_members, nan_members)]
    nan_members = nan_members[np.argsort(ratios)][::-1]

    # Omit frequent members until no unsolved equations remain:
    explained = np.zeros(nan_groups.shape[0], dtype=bool)
    valid_members = all_members.tolist()
    for entry in nan_members:
        if explained.all():
            break
        explained[(nan_groups == entry).any(axis=1)] = True
        valid_members.remove(entry)
    valid_members = np.array(valid_members)

    # Return options:
    if full_return:
        valid = ~nan_inds
        return estimates[valid], groups[valid], valid_members
    return valid_members</code></pre>
</details>
<div class="desc"><p>Checks which inputs are most likely responsible for unsolved equations.
Following combination-wise estimation of some variable, gets all input
combinations that produced NaN estimates and ranks the associated group
members by frequency of occurence in unsolved equations relative to the
total occurence in groups. Iterates over most frequent members until
all unsolved equations can be linked to at least one responsible input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>list</code> or <code>tuple</code> or <code>1D array (m,)</code> of <code>floats</code> or <code>ints</code> or <code>np.nans</code></dt>
<dd>Estimated variable for each group, as returned by combi_estimation().
All invalid outputs must be marked as NaN. No other values supported.</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>2D array (m, n)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Unique combinations of n inputs, as returned by combi_estimation().</dd>
<dt><strong><code>full_return</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, returns the subset of valid estimates and corresponding groups
in addition to the remaining group members. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>1D array (q,)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>Subset of valid estimates, equal to estimates[~np.isnan(estimates)].
Returned in first place if full_return is True, else omitted.</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>2D array (q, n)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>Subset of valid groups, equal to groups[~np.isnan(groups)].
Returned in second place if full_return is True, else omitted.</dd>
<dt><strong><code>members</code></strong> :&ensp;<code>1D array (p,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Remaining unique group members, likely not linked to any NaN estimates.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.combi_estimation"><code class="name flex">
<span>def <span class="ident">combi_estimation</span></span>(<span>positions, delays, mode, p1=0.0, axis=1, validate=True, filtered=False, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combi_estimation(positions, delays, mode, p1=0., axis=1, validate=True,
                     filtered=False, **kwargs):
    &#34;&#34;&#34; General micarray variable estimation by different channel combinations.
        Operates along a linear (horizontal or vertical) microphone array with
        a single reference channel at position p1 and a number of additional
        channels at the given positions, with a measured signal transmission
        delay relative to reference for each channel. Repeatedly calls the
        specified estimation function on each unique n-channel combination of
        positions and times to estimate a value. Both the channel positions and
        the time delays can be negative-valued. Accepts channel positions as
        both 2D and single coordinates, as long as all points are on a line in
        2D space with an orientation given by axis.

    Parameters
    ----------
    positions : array-like (m,) of (array-likes (2,)) of floats or ints
        Positions of additional (non-reference) channels along the array in m.
    delays : array-like (m,) of floats or ints
        Signal transmission delays between reference and each channel in s.
    mode : str
        Estimation function to call. Options are &#39;init&#39; for estimate_init(),
        &#39;x&#39; for estimate_x(), &#39;y&#39; for estimate_y(), &#39;sos&#39; for estimate_sos().
    p1 : float or int or array-like (2,) of floats or ints, optional
        Position of channel 1 (reference channel) along the array in m.
        The default is 0.0.
    axis : int, optional
        Dimension of 2D space along which the array is oriented. Options are
        either 0 (horizontal along x-axis) or 1 (vertical along y-axis).
        Ignored if validate is False. The default is 1.
    validate : bool, optional
        If True, calls collinear_coordinates() on p1 and positions to ensure
        that the orientation of the array is either horizontal or vertical, and
        redefines each point as a single coordinate along axis. If False, all
        channel positions must already be scalar. The default is True.
    filtered : bool, optional
        If True, calls filter_estimates() on the resulting estimates to check
        for NaN outputs (unsolved equations) and identify responsible channels.
        Returns the valid subsets of estimates and groups and the indices of
        remaining channels after filtering. The default is False.
    **kwargs : dict, optional
        Additional keyword arguments required by the estimation function.

    Returns
    -------
    estimates : 1D array (p,) of floats or ints (or np.nans)
        Estimated variable for each channel combination in groups. Invalid
        outputs are removed if filtered is True, else marked as NaN.
    groups : 2D array (p, n) of ints
        Unique combinations of n channel indices, corresponding to estimates.
    indices : 1D array (q,) of ints, optional
        Unique channel indices along positions, consistent with groups.
        Only returned if filtered is True.

    Raises
    ------
    ValueError
        Breaks if the number of given channel positions is insufficient for the
        requested estimation function, or if the number of positions does not
        match the number of specified time delays.
    &#34;&#34;&#34;
    # Input interpretation:
    func, n = {
        &#39;x&#39;: (estimate_x, 1),
        &#39;t1&#39;: (estimate_t1, 1),
        &#39;y&#39;: (estimate_y, 1),
        &#39;t1_first&#39;: (estimate_t1_first, 2),
        &#39;y_first&#39;: (estimate_y_first, 2),
        &#39;c&#39;: (estimate_c, 3),
    }[mode]

    # Input validation:
    if len(positions) &lt; n:
        msg = f&#39;Specify at least {n} channels in addition to the reference.&#39;
        raise ValueError(msg)
    if len(positions) != len(delays):
        raise ValueError(&#39;Specify one signal transmission delay per channel.&#39;)

    if validate:
        # Standardize and validate point coordinates:
        positions, _ = collinear_coordinates([p1, *positions], axis)
        p1, positions = positions[0], positions[1:]

    # Ensure iterable-indexable format:
    if not isinstance(positions, np.ndarray):
        positions = np.array(positions)
    if not isinstance(delays, np.ndarray):
        delays = np.array(delays)

    # Generate unique n-channel combinations (excluding reference):
    groups = np.array(list(combinations(range(positions.size), n)))

    # Combination-wise estimation:
    estimates = np.zeros(groups.shape[0])
    for i, group in enumerate(groups):
        estimates[i] = func(*positions[group], *delays[group], p1=p1,
                            axis=axis, validate=False, **kwargs)
    # Return options:
    if filtered:
        return filter_estimates(estimates, groups, full_return=True)
    return estimates, groups, np.arange(positions.shape[0])</code></pre>
</details>
<div class="desc"><p>General micarray variable estimation by different channel combinations.
Operates along a linear (horizontal or vertical) microphone array with
a single reference channel at position p1 and a number of additional
channels at the given positions, with a measured signal transmission
delay relative to reference for each channel. Repeatedly calls the
specified estimation function on each unique n-channel combination of
positions and times to estimate a value. Both the channel positions and
the time delays can be negative-valued. Accepts channel positions as
both 2D and single coordinates, as long as all points are on a line in
2D space with an orientation given by axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>array-like (m,)</code> of <code>(array-likes (2,))</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Positions of additional (non-reference) channels along the array in m.</dd>
<dt><strong><code>delays</code></strong> :&ensp;<code>array-like (m,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Signal transmission delays between reference and each channel in s.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Estimation function to call. Options are 'init' for estimate_init(),
'x' for estimate_x(), 'y' for estimate_y(), 'sos' for estimate_sos().</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>array-like (2,)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>Position of channel 1 (reference channel) along the array in m.
The default is 0.0.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Dimension of 2D space along which the array is oriented. Options are
either 0 (horizontal along x-axis) or 1 (vertical along y-axis).
Ignored if validate is False. The default is 1.</dd>
<dt><strong><code>validate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, calls collinear_coordinates() on p1 and positions to ensure
that the orientation of the array is either horizontal or vertical, and
redefines each point as a single coordinate along axis. If False, all
channel positions must already be scalar. The default is True.</dd>
<dt><strong><code>filtered</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, calls filter_estimates() on the resulting estimates to check
for NaN outputs (unsolved equations) and identify responsible channels.
Returns the valid subsets of estimates and groups and the indices of
remaining channels after filtering. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Additional keyword arguments required by the estimation function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>1D array (p,)</code> of <code>floats</code> or <code>ints (or np.nans)</code></dt>
<dd>Estimated variable for each channel combination in groups. Invalid
outputs are removed if filtered is True, else marked as NaN.</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>2D array (p, n)</code> of <code>ints</code></dt>
<dd>Unique combinations of n channel indices, corresponding to estimates.</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>1D array (q,)</code> of <code>ints</code>, optional</dt>
<dd>Unique channel indices along positions, consistent with groups.
Only returned if filtered is True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Breaks if the number of given channel positions is insufficient for the
requested estimation function, or if the number of positions does not
match the number of specified time delays.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.spatialtools.analyze_micarray"><code class="name flex">
<span>def <span class="ident">analyze_micarray</span></span>(<span>positions,<br>delays,<br>p1=0,<br>axis=1,<br>validate=True,<br>y_first=True,<br>filtered=True,<br>strict_filter=False,<br>condense_c=False,<br>n_close=5,<br>error={})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_micarray(positions, delays, p1=0, axis=1, validate=True,
                     y_first=True, filtered=True, strict_filter=False,
                     condense_c=False, n_close=5, error={}):

    offset = 0.0
    if validate:
        # Standardize and validate point coordinates:
        positions, offset = collinear_coordinates([p1, *positions], axis)
        p1, positions = positions[0], positions[1:]

    # Ensure iterable-indexable format:
    if not isinstance(positions, np.ndarray):
        positions = np.array(positions)
    if not isinstance(delays, np.ndarray):
        delays = np.array(delays)

    # Prepare general estimation arguments:
    args = dict(p1=p1, axis=axis, validate=False)
    combi_args = args | dict(filtered=filtered, y_first=y_first)

    # Estimate speed of sound:
    sos, groups, valid = combi_estimation(positions, delays, &#39;c&#39;, **combi_args)
    if strict_filter:
        inds = np.isin(groups, valid).all(axis=1)
        sos, groups = sos[inds], groups[inds]
    if condense_c:
        inds, _ = moving_center(sos, np.median, iterations=sos.size - n_close)
        sos, groups = sos[inds], groups[inds]

    # Initialize output storage:
    shape = (groups.shape[0], len(error) + 1) if error else (groups.shape[0])
    t1, y, x = [np.zeros(shape) for _ in range(3)]

    # Run downstream pipeline:
    channels = list(error.keys())
    for i in range(len(error) + 1):
        times = delays.copy()
        if i:
            # Update specific channel delay with fixed error:
            channel, deviation = channels[i - 1], error[channels[i - 1]]
            times[channel] += deviation

        # Focus on channel combinations with valid speed estimates:
        for j, (c, group) in enumerate(zip(sos, groups)):

            # Ensure to include error:
            if i and channel in group:
                group = np.roll(group, -np.nonzero(group == channel)[0][0])

            # Select channel subset:
            p, t = positions[group], times[group]
            # Map to storage index:
            ind = (j, i) if error else j

            if y_first:
                # Estimate y-coordinate of sender:
                y[ind] = estimate_y_first(*p[:-1], *t[:-1], c=c, **args)
                # Estimate initial runtime:
                t1[ind] = estimate_t1(*p[:-2], *t[:-2], c=c, y=y[ind], **args)
            else:
                # Estimate initial runtime:
                t1[ind] = estimate_t1_first(*p[:-1], *t[:-1], c=c, **args)
                # Estimate y-coordinate of sender:
                y[ind] = estimate_y(*p[:-2], *t[:-2], c=c, t1=t1[ind], **args)

            # Estimate x-coordinate of sender:
            x[ind] = estimate_x(p[0], t[0], c=c, t1=t1[ind], y=y[ind], **args)
    x += offset
    return sos, y, t1, x, groups</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderhopper.spatialtools.plot_micarray"><code class="name flex">
<span>def <span class="ident">plot_micarray</span></span>(<span>points,<br>ref=0,<br>axis=1,<br>ax=None,<br>mirror=False,<br>cross=True,<br>path=False,<br>circle=False,<br>radii=None,<br>delays=None,<br>c=None,<br>t1=None,<br>sender=None,<br>sender_x=None,<br>sender_y=None,<br>groups=None,<br>error={},<br>array_kwargs={},<br>ref_kwargs={},<br>sender_kwargs={},<br>cross_kwargs={},<br>plot_kwargs={},<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_micarray(points, ref=0, axis=1, ax=None, mirror=False, cross=True,
                  path=False, circle=False, radii=None, delays=None, c=None,
                  t1=None, sender=None, sender_x=None, sender_y=None, groups=None, error={},
                  array_kwargs={}, ref_kwargs={}, sender_kwargs={},
                  cross_kwargs={}, plot_kwargs={}, **kwargs):

    # Standardize and validate point coordinates:
    points = np.array(complete_coordinates(points, axis, n=2))
    if sender is not None:
        sender = complete_coordinates([sender], axis, template=np.zeros(2))[0]

    # Unpack reference channel and array coordinates:
    p1, array_x, array_y = points[ref, :], points[:, 0], points[:, 1]

    # Hierarchical input validation and completion:
    if radii is not None and len(radii) != points.shape[0]:
        msg = &#39;Specify one radius for each channel, including reference.&#39;\
             f&#39; Expected {points.shape[0]}, got {len(radii)}.&#39;
        raise ValueError(msg)
    elif radii is None and delays is not None: 
        if len(delays) != points.shape[0] - 1:
            msg = &#39;Specify one delay for each non-reference channel.&#39;\
                f&#39; Expected {points.shape[0] - 1}, got {len(delays)}.&#39;
            raise ValueError(msg)
        elif any([variable is None for variable in (c, t1, sender)]):
            # Estimate missing parameters, overriding any user input:
            out = analyze_micarray(array_y if axis else array_x, delays,
                                   p1[axis], axis, error=error, validate=False, **kwargs)
            c, sender_y, t1, sender_x, groups = out
        if np.isscalar(t1):
            radii = (np.insert(delays, ref, 0.0) + t1) * c
        else:
            radii = (np.insert(delays, ref, 0.0)[:, None] + t1) * c
    if (circle or path) and radii is None and sender is not None:
        # Mimic ideal signal transmission from sender:
        radii = np.linalg.norm(sender - points, axis=1)    

    # Define default plot arguments and update with user settings:
    cross_kwargs = dict(c=&#39;k&#39;, ls=&#39;dotted&#39;, lw=1, zorder=1) | cross_kwargs
    array_kwargs = dict(marker=&#39;o&#39;, ms=10, ls=&#39;-&#39;, lw=3, zorder=2,
                        c=&#39;k&#39;, mfc=&#39;w&#39;, mec=&#39;k&#39;) | array_kwargs | plot_kwargs
    ref_kwargs = dict(marker=&#39;o&#39;, ms=10, ls=&#39;&#39;, zorder=3,
                      c=&#39;k&#39;, mfc=&#39;k&#39;, mec=&#39;k&#39;) | ref_kwargs | plot_kwargs
    sender_kwargs = dict(marker=&#39;o&#39;, ms=10, ls=&#39;&#39;, zorder=4,
                         c=&#39;k&#39;, mfc=&#39;r&#39;, mec=&#39;k&#39;) | sender_kwargs | plot_kwargs

    # Manage subplot:
    if ax is None:
        _, ax = setup_fig(width=20, height=20, layout=&#39;constrained&#39;)

    # Plot microphone array:
    ax.plot(array_x, array_y, **array_kwargs)
    ax.plot(*p1, **ref_kwargs)
    if cross:
        # Indicate coordinate system:
        ax.axhline(0, **cross_kwargs)
        ax.axvline(0, **cross_kwargs)

    # Plot sender position:
    if sender is not None:
        ax.plot(*sender, **sender_kwargs)
        if mirror:
            # Account for symmetry:
            other_sender = sender.copy()
            other_sender[1 - axis] *= -1
            ax.plot(*other_sender, **sender_kwargs)

    if error:
        colors = [&#39;k&#39;] + color_range(&#39;turbo&#39;, len(error))

    if groups is not None:

        for i, group in enumerate(groups):
            # Plot perimeter around each channel:
            if circle and radii is not None:
                for r, p in zip(radii[group, i], points[group]):
                    if mirror:
                        # Draw full circle around each channel:
                        circle_x, circle_y = make_circle(r, *p, full=True)
                    else:
                        # Reduce to half-circle divided by axis:
                        circle_y, circle_x = make_circle(r, *p[::-1])
                    ax.plot(circle_x, circle_y, c=colors[i], lw=1)
            # Plot estimated sender positions:
            if sender_x is not None and sender_y is not None:
                ax.plot(sender_x[i], sender_y[i], c=colors[i], **plot_kwargs)
                if mirror:
                    coords = [sender_x[i], sender_y[i]]
                    coords[1 - axis] *= -1
                    ax.plot(*coords, c=colors[i], **plot_kwargs)
        return ax

    # Plot estimated sender positions:
    if sender_x is not None and sender_y is not None:
        ax.plot(sender_x, sender_y, **plot_kwargs)
        if mirror:
            coords = [sender_x, sender_y]
            coords[1 - axis] *= -1
            ax.plot(*coords, **plot_kwargs)

    # Plot perimeter around each channel:
    if circle and radii is not None:
        for radius, point in zip(radii, points):
            if mirror:
                # Draw full circle around each channel:
                circle_x, circle_y = make_circle(radius, *point, full=True)
            else:
                # Reduce to half-circle divided by axis:
                circle_y, circle_x = make_circle(radius, *point[::-1])
            ax.plot(circle_x, circle_y, c=&#39;k&#39;, lw=1)

    # Indicate signal transmission:
    # if path and sender is not None:
    #     sender_coords = np.repeat(sender[None, :], points.shape[0], axis=0)
    #     x, y = np.concatenate((points, sender_coords))
    #     x_coords = np.concatenate((sender_coords[:, 0], array_x))
    #     y_coords = np.concatenate((sender_coords[:, 1], array_y))
    return ax</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderhopper" href="index.html">thunderhopper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderhopper.spatialtools.speed_of_sound" href="#thunderhopper.spatialtools.speed_of_sound">speed_of_sound</a></code></li>
<li><code><a title="thunderhopper.spatialtools.complete_coordinates" href="#thunderhopper.spatialtools.complete_coordinates">complete_coordinates</a></code></li>
<li><code><a title="thunderhopper.spatialtools.collinear_coordinates" href="#thunderhopper.spatialtools.collinear_coordinates">collinear_coordinates</a></code></li>
<li><code><a title="thunderhopper.spatialtools.duplicate_coordinates" href="#thunderhopper.spatialtools.duplicate_coordinates">duplicate_coordinates</a></code></li>
<li><code><a title="thunderhopper.spatialtools.estimate_c" href="#thunderhopper.spatialtools.estimate_c">estimate_c</a></code></li>
<li><code><a title="thunderhopper.spatialtools.estimate_t1_first" href="#thunderhopper.spatialtools.estimate_t1_first">estimate_t1_first</a></code></li>
<li><code><a title="thunderhopper.spatialtools.estimate_t1" href="#thunderhopper.spatialtools.estimate_t1">estimate_t1</a></code></li>
<li><code><a title="thunderhopper.spatialtools.estimate_y_first" href="#thunderhopper.spatialtools.estimate_y_first">estimate_y_first</a></code></li>
<li><code><a title="thunderhopper.spatialtools.estimate_y" href="#thunderhopper.spatialtools.estimate_y">estimate_y</a></code></li>
<li><code><a title="thunderhopper.spatialtools.estimate_x" href="#thunderhopper.spatialtools.estimate_x">estimate_x</a></code></li>
<li><code><a title="thunderhopper.spatialtools.filter_estimates" href="#thunderhopper.spatialtools.filter_estimates">filter_estimates</a></code></li>
<li><code><a title="thunderhopper.spatialtools.combi_estimation" href="#thunderhopper.spatialtools.combi_estimation">combi_estimation</a></code></li>
<li><code><a title="thunderhopper.spatialtools.analyze_micarray" href="#thunderhopper.spatialtools.analyze_micarray">analyze_micarray</a></code></li>
<li><code><a title="thunderhopper.spatialtools.plot_micarray" href="#thunderhopper.spatialtools.plot_micarray">plot_micarray</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
