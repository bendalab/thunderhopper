<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderhopper.filters API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderhopper.filters</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderhopper.filters.decibel"><code class="name flex">
<span>def <span class="ident">decibel</span></span>(<span>data, ref=None, axis=None, lower_bound=1e-10)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decibel(data, ref=None, axis=None, lower_bound=1e-10):
    &#34;&#34;&#34; Logarithmic transformation of data to decibel (10 * log10(data / ref)).

    Parameters
    ----------
    data : ND-array of floats (arbitrary shape)
        Data to transform to dB.
    ref : float, optional
        Reference intensity for dB calculation that will correspond to 0 dB.
        If unspecified, uses the maximum over data. If axis is specified, uses
        the maximum along axis. If the maximum is 0, falls back to a reference
        value of 1. The default is None.
    lower_bound : float, optional
        Positive minimum capping value to avoid log(0). The default is 1e-10.

    Returns
    -------
    log_data : ND array of floats (data.shape)
        Logarithmically scaled data in dB.
    &#34;&#34;&#34;
    if ref is None:
        maximum = np.nanmax(data, axis=axis)
        ref = np.where(maximum != 0, maximum, 1)
    data = np.array(data)
    data[data &lt; lower_bound] = lower_bound
    return 10 * np.log10(data / ref)</code></pre>
</details>
<div class="desc"><p>Logarithmic transformation of data to decibel (10 * log10(data / ref)).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ND-array</code> of <code>floats (arbitrary shape)</code></dt>
<dd>Data to transform to dB.</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Reference intensity for dB calculation that will correspond to 0 dB.
If unspecified, uses the maximum over data. If axis is specified, uses
the maximum along axis. If the maximum is 0, falls back to a reference
value of 1. The default is None.</dd>
<dt><strong><code>lower_bound</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Positive minimum capping value to avoid log(0). The default is 1e-10.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>log_data</code></strong> :&ensp;<code>ND array</code> of <code>floats (data.shape)</code></dt>
<dd>Logarithmically scaled data in dB.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.downsampling"><code class="name flex">
<span>def <span class="ident">downsampling</span></span>(<span>data, rate, new_rate, axis=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downsampling(data, rate, new_rate, axis=0):
    &#34;&#34;&#34; Resamples time series data of given sampling rate to a lower new rate.
        Uses slicing along the specified axis where applicable. Otherwise, uses
        np.interp() for 1D data and scipy.interpolate.interpn() for ND data.
        Interpolation method is linear in both cases.

    Parameters
    ----------
    data : ND-array of floats (arbitrary shape)
        Data to be downsampled. Non-arrays are converted, if possible. Only the
        temporal array dimension specified by axis is resampled.
    rate : float or int
        Current sampling rate of data in Hz. Must be same for all time series.
    new_rate : float or int
        New sampling rate of data in Hz. Must be smaller than rate.
    axis : int, optional
        Time axis of data to be resampled. The default is 0.

    Returns
    -------
    downsampled : ND array of floats (data.shape except shape[axis])
        Downsampled data with the given new rate. Returns data unchanged if
        new_rate is not smaller than rate. Input dimensionality is preserved,
        but the size of axis is reduced.
    &#34;&#34;&#34;
    # Assert array (any shape):
    data = ensure_array(var=data, dtype=float)
    # Rate conflict early exit:
    if new_rate &gt;= rate:
        return data
    # Sampling rate ratio:
    n = rate / new_rate
    if abs(n - np.round(n)) &lt; 0.01:
        # Clean ratio early exit (nth-entry selection along axis):
        return array_slice(data, axis, step=int(np.round(n)))

    # Interpolation for non-integer ratios:
    t = np.arange(data.shape[0]) / rate
    new_t = np.arange(0, t[-1], 1 / new_rate)
    if data.ndim == 1:
        # 1D interpolation early exit:
        return np.interp(new_t, t, data)

    # Prepare for ND-interpolation along axis:
    data_coords = [np.arange(i) for i in data.shape]
    sample_coords = data_coords.copy()
    data_coords[axis], sample_coords[axis] = t, new_t
    # Expand from dimension-wise to point-wise coordinates:
    sample_coords = np.meshgrid(*sample_coords, indexing=&#39;ij&#39;)
    sample_coords = np.vstack([grid.ravel() for grid in sample_coords]).T
    # Interpolate from current onto new point grid:
    downsampled = interpn(data_coords, data, sample_coords)
    # Restore initial dimensionality:
    new_shape = list(data.shape)
    new_shape[axis] = len(new_t)
    return downsampled.reshape(new_shape)</code></pre>
</details>
<div class="desc"><p>Resamples time series data of given sampling rate to a lower new rate.
Uses slicing along the specified axis where applicable. Otherwise, uses
np.interp() for 1D data and scipy.interpolate.interpn() for ND data.
Interpolation method is linear in both cases.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ND-array</code> of <code>floats (arbitrary shape)</code></dt>
<dd>Data to be downsampled. Non-arrays are converted, if possible. Only the
temporal array dimension specified by axis is resampled.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Current sampling rate of data in Hz. Must be same for all time series.</dd>
<dt><strong><code>new_rate</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>New sampling rate of data in Hz. Must be smaller than rate.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Time axis of data to be resampled. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>downsampled</code></strong> :&ensp;<code>ND array</code> of <code>floats (data.shape except shape[axis])</code></dt>
<dd>Downsampled data with the given new rate. Returns data unchanged if
new_rate is not smaller than rate. Input dimensionality is preserved,
but the size of axis is reduced.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.repeated_downsampling"><code class="name flex">
<span>def <span class="ident">repeated_downsampling</span></span>(<span>data, rate, new_rates, avoid_interpol)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeated_downsampling(data, rate, new_rates, avoid_interpol):
    #TODO: Adapt to ND downsampling(?):
    &#34;&#34;&#34; Repeated downsampling of data to a series of new sampling rates.
        Used to recreate exact result of several downsampling steps in one go.
        Only useful if single downsampling yields unequal array lengths.

    Parameters
    ----------
    data : 1D array (m,) or 2D array (m, n) or list of floats or ints
        Data to be downsampled. Lists are converted to arrays (shape must be 1D
        or 2D). Any other input shapes result in a ValueError. If 2D,
        downsampling is done along the first axis, so that each column is
        treated as a separate time series.
    rate : float
        Original sampling rate of data in Hz.
    new_rates : list of floats (n,)
        New sampling rate of data at each downsampling step in Hz.
    avoid_interpol : bool or list of bools (n,)
        Before each downsampling step, adapts length of data to integer
        multiple of the ratio of the current and the next new sampling rate.
        Used to avoid interpolation during the respective downsampling step.
        First entry corresponds to step from rate to new_rates[0], second entry
        to step from new_rates[0] to new_rates[1], and so on.

    Returns
    -------
    downsampled : 1D array of floats (p,)
        Downsampled data with a sampling rate of new_rates[-1].
    &#34;&#34;&#34;
    downsampled = np.array(data)
    rates = [rate] + new_rates
    for i in range(len(rates) - 1):
        if avoid_interpol[i]:
            # Crop to multiple of sampling rate ratio:
            ratio = int(np.round(rates[i] / rates[i + 1]))
            downsampled[:(len(downsampled) // ratio) * ratio]
        # Downsampling step:
        downsampled = downsampling(downsampled, rates[i], rates[i + 1])
    return downsampled</code></pre>
</details>
<div class="desc"><p>Repeated downsampling of data to a series of new sampling rates.
Used to recreate exact result of several downsampling steps in one go.
Only useful if single downsampling yields unequal array lengths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1D array (m,)</code> or <code>2D array (m, n)</code> or <code>list</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Data to be downsampled. Lists are converted to arrays (shape must be 1D
or 2D). Any other input shapes result in a ValueError. If 2D,
downsampling is done along the first axis, so that each column is
treated as a separate time series.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Original sampling rate of data in Hz.</dd>
<dt><strong><code>new_rates</code></strong> :&ensp;<code>list</code> of <code>floats (n,)</code></dt>
<dd>New sampling rate of data at each downsampling step in Hz.</dd>
<dt><strong><code>avoid_interpol</code></strong> :&ensp;<code>bool</code> or <code>list</code> of <code>bools (n,)</code></dt>
<dd>Before each downsampling step, adapts length of data to integer
multiple of the ratio of the current and the next new sampling rate.
Used to avoid interpolation during the respective downsampling step.
First entry corresponds to step from rate to new_rates[0], second entry
to step from new_rates[0] to new_rates[1], and so on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>downsampled</code></strong> :&ensp;<code>1D array</code> of <code>floats (p,)</code></dt>
<dd>Downsampled data with a sampling rate of new_rates[-1].</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.sosfilter"><code class="name flex">
<span>def <span class="ident">sosfilter</span></span>(<span>data,<br>rate,<br>cutoff,<br>mode='lp',<br>order=1,<br>axis=0,<br>refilter=True,<br>padtype='even',<br>padlen=None,<br>padval=0.0,<br>sanitize_padlen=True,<br>zi=None,<br>init=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sosfilter(data, rate, cutoff, mode=&#39;lp&#39;, order=1, axis=0, refilter=True,
              padtype=&#39;even&#39;, padlen=None, padval=0., sanitize_padlen=True,
              zi=None, init=None):
    &#34;&#34;&#34; Applies a digital Butterworth filter in second-order sections format.
        Includes both the sosfilt() and sosfiltfilt() function of scipy.signal.
        Data can be filtered once (forward) or twice (forward-backward, which
        doubles the order of the filter and centers the phase of the output).
        Provides low-pass, high-pass, and band-pass filter types.

        Forward filters by sosfilt() can be set to a given initial state to
        control the start value. Forward-backward filters by sosfiltfilt() can
        be used with all built-in and a custom padding method. The refilter
        argument can be used to switch between the two functions.

    Parameters
    ----------
    data : ND array (any shape) of floats or ints
        Data to be filtered. Filter is applied along the specified time axis.
    rate : float or int
        Sampling rate of the time axis of data in Hz.
    cutoff : float or int or tuple (2,) of floats or ints
        Cut-off frequency of the applied filter in Hz. If mode is &#39;lp&#39; or &#39;hp&#39;,
        must be a single value. If mode is &#39;bp&#39;, must be a tuple of two values.
    mode : str, optional
        Type of the applied filter. Options are &#39;lp&#39; (low-pass), &#39;hp&#39;
        (high-pass), and &#39;bp&#39; (band-pass). The default is &#39;lp&#39;.
    order : int, optional
        Order of the applied filter. If refilter is True, actual filter order
        is twice the specified order. The default is 1.
    axis : int, optional
        Time axis of data along which to apply the filter. The default is 0.
    refilter : bool, optional
        If True, uses the forward-backward filtering method of sosfiltfilt(),
        which enables use of padtype, padlen, and padval to control padding. If
        False, uses the forward filtering method of sosfilt(), which enables
        use of zi and init to control the start value. The default is True.
    padtype : str, optional
        Method used to pad the data before forward-backward filtering. Can be:
        # &#39;constant&#39;: Pads with first and last value of data, respectively.
        -&gt; For signals with assessable endpoints (e.g. bound to some baseline).
        # &#39;even&#39;: Mirrors the data around each endpoint.
        -&gt; For (noisy) signals whose statistics do not change much over time.
        # &#39;odd&#39;: Mirrors data, then turns it 180° around the endpoint.
        -&gt; For oscillatory signals or where stable phase and smoothness is key.
        # &#39;fixed&#39;: Pads with padval (managed externally, not by scipy).
        -&gt; For signals that are meant to be seen in a certain temporal context.
        # None: No padding.
        Ignored if refilter is False. The default is &#39;even&#39;.
    padlen : int, optional
        Number of points added to each side of data. Applies for any padtype.
        Calculated by sosfiltfilt() as a very small number of points if None.
        Ignored if refilter is False or padtype is None or padtype is &#39;fixed&#39;
        with padval being an array. If sanitize_padlen is True and padtype is
        a built-in method, may be reduced to avoid errors. The default is None.
    padval : float or int or ND array (any shape) of floats or ints, optional
        If specified and padtype is &#39;fixed&#39;, used as custom padding. If scalar,
        creates a constant padding of size padlen with the given value. If
        array, must have the same shape as data except along axis, so that it
        can be concatenated to data. Ignored if refilter is False or padtype is
        not &#39;fixed&#39;. The default is 0.0.
    sanitize_padlen : bool, optional
        If True and padtype is a built-in method with padlen specified, clips
        padlen to be less than the size of the time axis of data, avoiding an
        internal sosfiltfilt() error. Ignored if refilter is False or padlen is
        None or padtype is &#39;fixed&#39;. The default is True.
    zi : ND array of floats, optional
        If specified, sets the initial state for each second-order section of
        the applied forward filter, which in turn determines the start value(s)
        for filtering. Either returned by sosfilt() after a previous filtering
        step, or constructed manually. Shape must be (n_sections, ..., 2, ...),
        where n_sections equals sos.shape[0] and ..., 2, ... is the shape of
        data with data.shape[axis] replaced by 2. Use sosfilt_zi() to generate
        the initial state for a single section. If None, creates a filter state
        array of matching shape and adapts the inital state to the start value
        specified by init. Ignored if refilter is True. The default is None.
    init : float or int or ND array (any shape) of floats or ints, optional
        If specified and zi is None, adapts the initial filter state to this
        start values(s). If scalar, determines the start value for all filtered
        slices in data. If array, must have the same shape as data (except that
        init.shape[axis] must be 1) to set the start value for each slice. If
        None, uses the values of the first slice of data along axis. Ignored if
        refilter is True or zi is specified. The default is None.

    Returns
    -------
    filtered : ND array (data.shape) of floats
        Filtered data along the given time axis. If refilter is True, output of
        sosfiltfilt(), else sosfilt(). If mode is &#39;lp&#39; and cutoff is above the
        Nyquist frequency (rate / 2), returns unchanged data. If mode is &#39;bp&#39;
        and cutoff[1] is above Nyquist, falls back to pure high-pass filtering.
    next_state : ND array (zi.shape) of floats
        New filter state array after the applied forward filtering step to pass
        on with the next function call. Only returned if refilter is False. 
    &#34;&#34;&#34;
    # Nyquist low-pass early exit:
    if mode == &#39;lp&#39; and cutoff &gt; rate / 2:
        return data
    # Nyquist band-pass fallback to high-pass:
    elif mode == &#39;bp&#39; and cutoff[1] &gt; rate / 2:
        mode, cutoff = &#39;hp&#39;, cutoff[0]

    # Initialize filter as second-order sections:
    sos = butter(order, cutoff, mode, fs=rate, output=&#39;sos&#39;)

    # FORWARDS:
    if not refilter:
        if zi is None:
            # Initialize filter state array:
            data_shape = list(data.shape)
            data_shape[axis] = 2
            # Shape must be (n_sections, ..., 2, ...):
            zi = np.zeros([sos.shape[0]] + data_shape)

            # Construct initial state:
            shape = [1] * data.ndim
            shape[axis] = 2
            # Shape must be (..., 2, ...):
            init_state = sosfilt_zi(sos).reshape(shape)
            if init is None:
                # Take values of 1st slice along axis:
                init = array_slice(data, axis, 0, 1)

            # Adapt filter state per section:
            for i in range(sos.shape[0]):
                zi[i] = init_state * init

        # Apply filter once with given state and start value:
        filtered, next_state = sosfilt(sos, data, axis, zi)
        return filtered, next_state

    # FORWARDS-BACKWARDS:
    if padtype == &#39;fixed&#39;:
        # Manage custom padding options:
        if isinstance(padval, np.ndarray):
            # Individual values:
            if padval.ndim != data.ndim:
                msg = &#39;If padval is an array, must have the same dimensions&#39;\
                      &#39;as data and be of matching shape except along axis.&#39;
                raise ValueError(msg)
            data = np.concatenate((padval, data, padval), axis=axis)
            padlen = padval.shape[axis]
        else:
            # Constant value: 
            if padlen is None:
                # Auto-generated as per scipy default:
                padlen = 3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),
                                                     (sos[:, 5] == 0).sum()))
            padding = [(0, 0)] * data.ndim
            padding[axis] = (padlen, padlen)
            data = np.pad(data, padding, constant_values=padval)

    # Clip to maximum allowed padding length to avoid scipy error:    
    elif sanitize_padlen and padlen is not None and padlen &gt;= data.shape[axis]:
        padlen = data.shape[axis] - 1

    # Apply filter twice with given padding method:
    filtered = sosfiltfilt(sos, data, axis, padlen=padlen,
                           padtype=None if padtype == &#39;fixed&#39; else padtype)
    # Return options:
    if padtype == &#39;fixed&#39;:
        # Remove custom padding manually:
        start, stop = padlen, data.shape[axis] - padlen
        return array_slice(filtered, axis, start, stop)
    return filtered</code></pre>
</details>
<div class="desc"><p>Applies a digital Butterworth filter in second-order sections format.
Includes both the sosfilt() and sosfiltfilt() function of scipy.signal.
Data can be filtered once (forward) or twice (forward-backward, which
doubles the order of the filter and centers the phase of the output).
Provides low-pass, high-pass, and band-pass filter types.</p>
<pre><code>Forward filters by sosfilt() can be set to a given initial state to
control the start value. Forward-backward filters by sosfiltfilt() can
be used with all built-in and a custom padding method. The refilter
argument can be used to switch between the two functions.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ND array (any shape)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Data to be filtered. Filter is applied along the specified time axis.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Sampling rate of the time axis of data in Hz.</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>tuple (2,)</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Cut-off frequency of the applied filter in Hz. If mode is 'lp' or 'hp',
must be a single value. If mode is 'bp', must be a tuple of two values.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of the applied filter. Options are 'lp' (low-pass), 'hp'
(high-pass), and 'bp' (band-pass). The default is 'lp'.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Order of the applied filter. If refilter is True, actual filter order
is twice the specified order. The default is 1.</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Time axis of data along which to apply the filter. The default is 0.</dd>
<dt><strong><code>refilter</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, uses the forward-backward filtering method of sosfiltfilt(),
which enables use of padtype, padlen, and padval to control padding. If
False, uses the forward filtering method of sosfilt(), which enables
use of zi and init to control the start value. The default is True.</dd>
<dt><strong><code>padtype</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method used to pad the data before forward-backward filtering. Can be:<h1 id="constant-pads-with-first-and-last-value-of-data-respectively">'constant': Pads with first and last value of data, respectively.</h1>
-&gt; For signals with assessable endpoints (e.g. bound to some baseline).<h1 id="even-mirrors-the-data-around-each-endpoint">'even': Mirrors the data around each endpoint.</h1>
-&gt; For (noisy) signals whose statistics do not change much over time.<h1 id="odd-mirrors-data-then-turns-it-180-around-the-endpoint">'odd': Mirrors data, then turns it 180° around the endpoint.</h1>
-&gt; For oscillatory signals or where stable phase and smoothness is key.<h1 id="fixed-pads-with-padval-managed-externally-not-by-scipy">'fixed': Pads with padval (managed externally, not by scipy).</h1>
-&gt; For signals that are meant to be seen in a certain temporal context.<h1 id="none-no-padding">None: No padding.</h1>
Ignored if refilter is False. The default is 'even'.</dd>
<dt><strong><code>padlen</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of points added to each side of data. Applies for any padtype.
Calculated by sosfiltfilt() as a very small number of points if None.
Ignored if refilter is False or padtype is None or padtype is 'fixed'
with padval being an array. If sanitize_padlen is True and padtype is
a built-in method, may be reduced to avoid errors. The default is None.</dd>
<dt><strong><code>padval</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>ND array (any shape)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>If specified and padtype is 'fixed', used as custom padding. If scalar,
creates a constant padding of size padlen with the given value. If
array, must have the same shape as data except along axis, so that it
can be concatenated to data. Ignored if refilter is False or padtype is
not 'fixed'. The default is 0.0.</dd>
<dt><strong><code>sanitize_padlen</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True and padtype is a built-in method with padlen specified, clips
padlen to be less than the size of the time axis of data, avoiding an
internal sosfiltfilt() error. Ignored if refilter is False or padlen is
None or padtype is 'fixed'. The default is True.</dd>
<dt><strong><code>zi</code></strong> :&ensp;<code>ND array</code> of <code>floats</code>, optional</dt>
<dd>If specified, sets the initial state for each second-order section of
the applied forward filter, which in turn determines the start value(s)
for filtering. Either returned by sosfilt() after a previous filtering
step, or constructed manually. Shape must be (n_sections, &hellip;, 2, &hellip;),
where n_sections equals sos.shape[0] and &hellip;, 2, &hellip; is the shape of
data with data.shape[axis] replaced by 2. Use sosfilt_zi() to generate
the initial state for a single section. If None, creates a filter state
array of matching shape and adapts the inital state to the start value
specified by init. Ignored if refilter is True. The default is None.</dd>
<dt><strong><code>init</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>ND array (any shape)</code> of <code>floats</code> or <code>ints</code>, optional</dt>
<dd>If specified and zi is None, adapts the initial filter state to this
start values(s). If scalar, determines the start value for all filtered
slices in data. If array, must have the same shape as data (except that
init.shape[axis] must be 1) to set the start value for each slice. If
None, uses the values of the first slice of data along axis. Ignored if
refilter is True or zi is specified. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filtered</code></strong> :&ensp;<code>ND array (data.shape)</code> of <code>floats</code></dt>
<dd>Filtered data along the given time axis. If refilter is True, output of
sosfiltfilt(), else sosfilt(). If mode is 'lp' and cutoff is above the
Nyquist frequency (rate / 2), returns unchanged data. If mode is 'bp'
and cutoff[1] is above Nyquist, falls back to pure high-pass filtering.</dd>
<dt><strong><code>next_state</code></strong> :&ensp;<code>ND array (zi.shape)</code> of <code>floats</code></dt>
<dd>New filter state array after the applied forward filtering step to pass
on with the next function call. Only returned if refilter is False.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.envelope"><code class="name flex">
<span>def <span class="ident">envelope</span></span>(<span>data, rate, cutoff=500.0, env_rate=2000.0, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envelope(data, rate, cutoff=500., env_rate=2000., **kwargs):
    &#34;&#34;&#34; Extracts the signal envelope by low-pass filtering the rectified data.
        Envelope can be resampled to a lower rate to reduce memory load.

    Parameters
    ----------
    data : ND array of floats or ints
        Data to be filtered. Non-arrays are converted, if possible. If 1D,
        assumes a single time series. If 2D, assumes that each column is a
        separate time series and performs filtering along the first axis.
    rate : float or int
        Sampling rate of data in Hz.
    cutoff : float or int, optional
        Cut-off frequency of the low-pass filter in Hz. The default is 500.0.
    env_rate : float or int, optional
        Sampling rate of the resampled envelope in Hz. Skips downsampling if
        env_rate &gt;= rate. The default is 2000.0.
    **kwargs : dict, optional
        Additional keyword arguments passed to sosfilter(). Can be used to
        modify properties of the applied low-pass filter.

    Returns
    -------
    env : 1D array (p,) or 2D array (p, n) of floats
        Extracted signal envelope with given sampling rate for each time series
        in data. Returns 1D if input was 1D, else 2D.
    &#34;&#34;&#34;
    filtered = sosfilter(np.abs(data), rate, cutoff, mode=&#39;lp&#39;, **kwargs)
    env = downsampling(filtered, rate, env_rate)
    return env</code></pre>
</details>
<div class="desc"><p>Extracts the signal envelope by low-pass filtering the rectified data.
Envelope can be resampled to a lower rate to reduce memory load.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ND array</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Data to be filtered. Non-arrays are converted, if possible. If 1D,
assumes a single time series. If 2D, assumes that each column is a
separate time series and performs filtering along the first axis.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Sampling rate of data in Hz.</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>float</code> or <code>int</code>, optional</dt>
<dd>Cut-off frequency of the low-pass filter in Hz. The default is 500.0.</dd>
<dt><strong><code>env_rate</code></strong> :&ensp;<code>float</code> or <code>int</code>, optional</dt>
<dd>Sampling rate of the resampled envelope in Hz. Skips downsampling if
env_rate &gt;= rate. The default is 2000.0.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Additional keyword arguments passed to sosfilter(). Can be used to
modify properties of the applied low-pass filter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>env</code></strong> :&ensp;<code>1D array (p,)</code> or <code>2D array (p, n)</code> of <code>floats</code></dt>
<dd>Extracted signal envelope with given sampling rate for each time series
in data. Returns 1D if input was 1D, else 2D.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.multi_lowpass"><code class="name flex">
<span>def <span class="ident">multi_lowpass</span></span>(<span>data, rate, cutoffs, new_rate=None, rectify=False, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_lowpass(data, rate, cutoffs, new_rate=None, rectify=False, **kwargs):
    &#34;&#34;&#34; Temporal averaging of data on multiple different time scales.
        Applies separate low-pass filters with the given cut-off frequencies.
        Data can be rectified before filtering to perform envelope extraction.
        Filtered data can then be downsampled to a new rate.

    Parameters
    ----------
    data : 1D array (m,) or 2D array (m, n) or list of floats or ints
        Data to be averaged by low-pass filtering. Non-arrays are converted, if
        possible. If 1D, assumes a single time series. If 2D, assumes that each
        column is a separate time series and averages along the first axis.
    rate : float or int
        Sampling rate of data in Hz. Must be the same for all columns.
    cutoffs : float or int or list of floats or ints (p,)
        Cut-off frequency of each applied low-pass filter in Hz. Accepts
        scalars (discouraged, use sosfilter() with downsampling() instead). For
        each specified cut-off frequency, adds a block with as many columns as
        data to the filtered array.
    new_rate : float or int
        If specified, downsamples filtered data to this rate in Hz. Ignored if
        new_rate &gt;= rate. The default is None.
    rectify : bool, optional
        If True, applies np.abs() to data before low-pass filtering, turning
        temporal averaging into envelope extraction. The default is False.
    **kwargs : dict, optional
        Additional keyword arguments passed to sosfilter() to control the order
        of the low-pass filter, the filtering method, padding and start values.

    Returns
    -------
    filtered : 2D array of floats (q, n * p)
        Temporally averaged data, optionally downsampled. Columns correspond to
        filtered time series and are ordered block-wise by cut-off frequency of
        each applied low-pass filter. Block order is the same as in cutoffs.
        Within-block column order is the same as in data.
    &#34;&#34;&#34;
    # Assert 2D array (columns):
    data = ensure_array(var=data, dims=(1, 2), shape=(-1, None))
    # Assert iterable:
    cutoffs = check_list(cutoffs)
    # Manage envelope mode:
    if rectify:
        data = np.abs(data)
    # Manage downsampling:
    if new_rate is None:
        new_rate = rate

    # Time series in data array:
    n_columns = data.shape[1]
    # Length of the (downsampled) time axis:
    n_resampled = int(np.round(new_rate / rate * data.shape[0]))
    # Initialize filtered array as horizontal tile of data array:
    filtered = np.zeros((n_resampled, n_columns * len(cutoffs)))
    for i, cutoff in enumerate(cutoffs):
        # Indices of next filter block along second axis:
        block = np.arange(i * n_columns, (i + 1) * n_columns, dtype=int)
        # Apply low-pass filter for given block to data array:
        filter_block = sosfilter(data, rate, cutoff, &#39;lp&#39;, **kwargs)
        filtered[:, block] = downsampling(filter_block, rate, new_rate)
    return filtered</code></pre>
</details>
<div class="desc"><p>Temporal averaging of data on multiple different time scales.
Applies separate low-pass filters with the given cut-off frequencies.
Data can be rectified before filtering to perform envelope extraction.
Filtered data can then be downsampled to a new rate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1D array (m,)</code> or <code>2D array (m, n)</code> or <code>list</code> of <code>floats</code> or <code>ints</code></dt>
<dd>Data to be averaged by low-pass filtering. Non-arrays are converted, if
possible. If 1D, assumes a single time series. If 2D, assumes that each
column is a separate time series and averages along the first axis.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>Sampling rate of data in Hz. Must be the same for all columns.</dd>
<dt><strong><code>cutoffs</code></strong> :&ensp;<code>float</code> or <code>int</code> or <code>list</code> of <code>floats</code> or <code>ints (p,)</code></dt>
<dd>Cut-off frequency of each applied low-pass filter in Hz. Accepts
scalars (discouraged, use sosfilter() with downsampling() instead). For
each specified cut-off frequency, adds a block with as many columns as
data to the filtered array.</dd>
<dt><strong><code>new_rate</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>If specified, downsamples filtered data to this rate in Hz. Ignored if
new_rate &gt;= rate. The default is None.</dd>
<dt><strong><code>rectify</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, applies np.abs() to data before low-pass filtering, turning
temporal averaging into envelope extraction. The default is False.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Additional keyword arguments passed to sosfilter() to control the order
of the low-pass filter, the filtering method, padding and start values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filtered</code></strong> :&ensp;<code>2D array</code> of <code>floats (q, n * p)</code></dt>
<dd>Temporally averaged data, optionally downsampled. Columns correspond to
filtered time series and are ordered block-wise by cut-off frequency of
each applied low-pass filter. Block order is the same as in cutoffs.
Within-block column order is the same as in data.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.gabor_function"><code class="name flex">
<span>def <span class="ident">gabor_function</span></span>(<span>sigma, freq, phase, rate=1000, time=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gabor_function(sigma, freq, phase, rate=1000, time=None):
    &#34;&#34;&#34; Creates a Gabor function by multiplication of a Gaussian and a sine.
        The Gaussian envelope constrains the sinusoidal carrier to a certain
        time interval, resulting in several amplitude-modulated oscillations
        that form the lobes of the Gabor. The number of lobes depends on the
        combination of carrier frequency and envelope width. Lobe alignment and
        sign of the Gabor depend on the phase shift of the carrier. Accepts any
        of sigma, freq, and phase as arrays, as long as they can be broadcast
        to a common output shape together with time.

    Parameters
    ----------
    sigma : int or float or array of ints or floats
        Standard deviation of the Gaussian envelope in s.
    freq : int or float or array of ints or floats
        Frequency of the sinusoidal carrier in Hz.
    phase : int or float or array of ints or floats
        Phase-shift of the sinusoidal carrier in radians.
    rate : int or float, optional
        Sampling rate of the Gabor in Hz. If time is None, used to generate
        the underlying time axis, else ignored. The default is 1000.
    time : array of ints or floats, optional
        Time axis underlying the Gabor in s. Replaces rate if specified, else
        calculated with rate over [-4 * sigma, 4 * sigma]. The generated time
        array matches the output dimensionality defined by sigma, freq, and
        phase, assuming the first dimension is time. The default is None.

    Returns
    -------
    gabor : array of floats
        Gabor function with given Gaussian envelope and sinusoidal carrier.
        Can return multiple Gabors if sigma, freq, or phase are arrays.
    time : array of ints or floats
        Time axis underlying the Gabor in s. If time is specified, returns the
        given array, else the generated array over [-4 * sigma, 4 * sigma].
        Returns a single time axis even if multiple Gabors are returned.
    &#34;&#34;&#34;
    # Validate broadcasting across Gabor parameters:
    shape = broadcastable(vars=(sigma, freq, phase), crash=True)
    if time is None:
        # Scale time axis to hold the widest Gabor:
        sd = sigma if np.size(sigma) == 1 else sigma.max()
        # Generate time axis array and ensure it is broadcastable:
        time = remap_array(mirror_linspace(4 * sd, rate), {0:0}, shape=shape)

    # Compute components and resulting Gabor:
    gauss = np.exp(-0.5 * (time / sigma)**2)
    sine = np.sin(2 * np.pi * freq * time + phase)
    return gauss * sine, time</code></pre>
</details>
<div class="desc"><p>Creates a Gabor function by multiplication of a Gaussian and a sine.
The Gaussian envelope constrains the sinusoidal carrier to a certain
time interval, resulting in several amplitude-modulated oscillations
that form the lobes of the Gabor. The number of lobes depends on the
combination of carrier frequency and envelope width. Lobe alignment and
sign of the Gabor depend on the phase shift of the carrier. Accepts any
of sigma, freq, and phase as arrays, as long as they can be broadcast
to a common output shape together with time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>array</code> of <code>ints</code> or <code>floats</code></dt>
<dd>Standard deviation of the Gaussian envelope in s.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>array</code> of <code>ints</code> or <code>floats</code></dt>
<dd>Frequency of the sinusoidal carrier in Hz.</dd>
<dt><strong><code>phase</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>array</code> of <code>ints</code> or <code>floats</code></dt>
<dd>Phase-shift of the sinusoidal carrier in radians.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Sampling rate of the Gabor in Hz. If time is None, used to generate
the underlying time axis, else ignored. The default is 1000.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>array</code> of <code>ints</code> or <code>floats</code>, optional</dt>
<dd>Time axis underlying the Gabor in s. Replaces rate if specified, else
calculated with rate over [-4 * sigma, 4 * sigma]. The generated time
array matches the output dimensionality defined by sigma, freq, and
phase, assuming the first dimension is time. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>gabor</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>Gabor function with given Gaussian envelope and sinusoidal carrier.
Can return multiple Gabors if sigma, freq, or phase are arrays.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>array</code> of <code>ints</code> or <code>floats</code></dt>
<dd>Time axis underlying the Gabor in s. If time is specified, returns the
given array, else the generated array over [-4 * sigma, 4 * sigma].
Returns a single time axis even if multiple Gabors are returned.</dd>
</dl></div>
</dd>
<dt id="thunderhopper.filters.gabor_kernels"><code class="name flex">
<span>def <span class="ident">gabor_kernels</span></span>(<span>sigmas,<br>n_lobes,<br>signs,<br>rate=1000,<br>time=None,<br>as_array=True,<br>normalize=False,<br>freq_kwargs={},<br>flat_flanks=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gabor_kernels(sigmas, n_lobes, signs, rate=1000, time=None, as_array=True,
                  normalize=False, freq_kwargs={}, flat_flanks=False):
    #TODO: Add docstring!
    # Ensure array format (also effective downstream):
    check = lambda x: x if isinstance(x, np.ndarray) else np.array(x, ndmin=1)
    sigmas, n_lobes, signs = (check(var) for var in (sigmas, n_lobes, signs))

    # Get parameters of the carrier for each kernel:
    phases = gabor_phase(n_lobes, signs, radians=True)
    if &#39;rel_height&#39; in freq_kwargs: 
        # Compute Gaussian widths at relative height:
        widths = gauss_width(sigmas, freq_kwargs.pop(&#39;rel_height&#39;))
        # Update frequency settings:
        freq_kwargs[&#39;gauss_width&#39;] = widths
    freqs = gabor_freqs(n_lobes, sigma=sigmas, **freq_kwargs)

    # Accumulate Gabor parameters of each kernel in the set:
    params, param_generator = [], zip(sigmas, freqs, phases, n_lobes, signs)
    for sigma, freq, phase, n, sign in param_generator:
        params.append({
            &#39;sigma&#39;: sigma,
            &#39;freq&#39;: freq,
            &#39;phase&#39;: phase,
            &#39;lobes&#39;: int(n),
            &#39;sign&#39;: int(sign)})

    # Run parallel:
    if as_array:
        # Generate full kernel set as 2D array (time x kernels):
        kernels, time = gabor_function(sigmas[None, :], freqs[None, :],
                                       phases[None, :], rate, time)

        # Apply post-generation adjustments to kernel array:
        if flat_flanks and &#39;gauss_width&#39; in freq_kwargs:
            # Optional wiping of lobes beyond Gaussian width:
            inds = (np.abs(time) &gt; freq_kwargs[&#39;gauss_width&#39;]) &amp; (n_lobes &gt; 1)
            if inds.any():
                kernels[inds] = 0
        if normalize:
            # Optional kernel integral normalization:
            kernels /= np.sqrt(np.trapezoid(kernels**2, time, axis=0))
        return kernels, time, params

    # Run in series:
    kernels, times = [], []
    param_generator = zip(sigmas, freqs, phases, n_lobes)
    for i, (sigma, freq, phase, n) in enumerate(param_generator):
        # Generate single kernel with individual time axis:
        gabor, t = gabor_function(sigma, freq, phase, rate, time)
        # Apply post-generation adjustments and log variables:
        if flat_flanks and &#39;gauss_width&#39; in freq_kwargs and n &gt; 1:
            gabor[abs(t) &gt; freq_kwargs[&#39;gauss_width&#39;][i]] = 0
        if normalize:
            gabor /= np.sqrt(np.trapezoid(gabor**2, t))
        kernels.append(gabor), times.append(t)
    return kernels, times, params</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderhopper.filters.gabor_set"><code class="name flex">
<span>def <span class="ident">gabor_set</span></span>(<span>rate=1000,<br>kernel_dict=None,<br>types=None,<br>sigmas=None,<br>channels=None,<br>specs=None,<br>as_array=True,<br>shared_params=(),<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gabor_set(rate=1000, kernel_dict=None, types=None, sigmas=None,
              channels=None, specs=None, as_array=True, shared_params=(),
              **kwargs):
    #TODO: Add docstring!
    # Input interpretation:
    if specs is None:
        # Sanitize input parameter sets and create specifier array:
        specs = encode_kernels(kernel_dict, types, sigmas, channels,
                               shared_params=shared_params)

    # Generate set of Gabor kernels of given sigma, lobe number, and sign:
    kernels, times, params = gabor_kernels(specs[:, 1], np.abs(specs[:, 0]),
                                           np.sign(specs[:, 0]), rate=rate,
                                           as_array=as_array, **kwargs)                          
    if specs.shape[1] == 2:
        # No channel axis early exit:
        return kernels, specs, times, params

    # Expand each 1D kernel array to 2D (time x channels):
    param_generator = zip(kernels.T if as_array else kernels, specs[:, 2])
    kernels = [np.tile(k[:, None], (1, int(n))) for k, n in param_generator]
    if as_array:
        # Fuse into single 3D array (time x channels x kernels):
        kernels = align_arrays(kernels, new_axis=2, align=&#39;center&#39;)
    return kernels, specs, times, params</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderhopper" href="index.html">thunderhopper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderhopper.filters.decibel" href="#thunderhopper.filters.decibel">decibel</a></code></li>
<li><code><a title="thunderhopper.filters.downsampling" href="#thunderhopper.filters.downsampling">downsampling</a></code></li>
<li><code><a title="thunderhopper.filters.repeated_downsampling" href="#thunderhopper.filters.repeated_downsampling">repeated_downsampling</a></code></li>
<li><code><a title="thunderhopper.filters.sosfilter" href="#thunderhopper.filters.sosfilter">sosfilter</a></code></li>
<li><code><a title="thunderhopper.filters.envelope" href="#thunderhopper.filters.envelope">envelope</a></code></li>
<li><code><a title="thunderhopper.filters.multi_lowpass" href="#thunderhopper.filters.multi_lowpass">multi_lowpass</a></code></li>
<li><code><a title="thunderhopper.filters.gabor_function" href="#thunderhopper.filters.gabor_function">gabor_function</a></code></li>
<li><code><a title="thunderhopper.filters.gabor_kernels" href="#thunderhopper.filters.gabor_kernels">gabor_kernels</a></code></li>
<li><code><a title="thunderhopper.filters.gabor_set" href="#thunderhopper.filters.gabor_set">gabor_set</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
